# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

> **About this file (v4.0.0):** Project-specific guidelines for bujo, a Go-based CLI Bullet Journal.
>
> **Architecture:**
> - **CLAUDE.md** (this file): Project context, commands, and architecture
> - **Skills**: Detailed patterns loaded on-demand (tdd, testing, functional, refactoring, planning)
> - **Agents**: Specialized subprocesses for verification and analysis
> - **spec.md**: Complete technical specification

## Project Overview

bujo is a high-performance, Go-based command-line Bullet Journal for macOS. It captures tasks, notes, events, habits, and locations with AI-powered reflections using Google's Gemini API.

**Tech Stack:** Go 1.23, SQLite, Cobra CLI, Gemini API

## Build Commands

```bash
go build -o bujo ./cmd/bujo     # Build binary
go test ./...                    # Run all tests
go test ./internal/domain/...   # Run domain tests only
go test -v -run TestName ./...  # Run specific test
go test -cover ./...            # Run with coverage
go vet ./...                    # Static analysis
```

## DATABASE SAFETY (CRITICAL)

**NEVER run the application or commands without explicitly specifying a test database.**

- **Tests**: Always use in-memory databases (`:memory:`) or test fixture databases
- **Manual testing**: Always use `--db-path /path/to/test.db` with a dedicated test database
- **NEVER** run `./bujo` without `--db-path` flag - it may default to production database
- **NEVER** assume the default database is safe to modify

```bash
# CORRECT - explicit test database
./bujo --db-path ./test.db add "test entry"
./bujo --db-path :memory: habit list

# WRONG - may corrupt production data
./bujo add "test entry"
./bujo habit log "exercise"
```

**If you're about to run the bujo binary, STOP and verify you have `--db-path` set.**

## Architecture

Hexagonal Architecture with clear separation:

```
cmd/bujo/           CLI entry point (Cobra adapter)
internal/
  domain/           Core business logic (100% TDD coverage required)
    entry.go        Entry types: Task (.), Note (-), Event (o), Done (x), Migrated (>)
    habit.go        Habit tracking with multi-log support
    summary.go      AI summary types
    parser.go       TreeParser for hierarchical input
  service/          Stateless services (BujoService, HabitService)
  repository/       SQLite repository implementations
  adapter/
    cli/            Cobra command handlers
    ai/             Gemini integration
```

**Key Principle:** Business logic isolated in `internal/domain`. CLI and future web server are adapters to shared logic.

## Data Model

SQLite with these tables:
- `entries`: Hierarchical items with `parent_id` for tree structure
- `habits`: Recurring habits with `goal_per_day`
- `habit_logs`: Multiple logs per habit per day
- `day_context`: Daily location, mood, weather
- `summaries`: Cached AI summaries (daily/weekly/quarterly/annual)

## Event Sourcing (MANDATORY)

**ALL entities use event sourcing.** Every mutation creates a new versioned row.

**Exception:** The `summaries` table does not use event sourcing. Summaries are cached AI-generated content that can be regenerated by calling the Gemini API, so they don't require an audit trail.

### Event Sourcing Columns (on all entity tables)

| Column | Purpose |
|--------|---------|
| `entity_id` | Stable UUID identifying the logical entity across versions |
| `version` | Incrementing version number (1, 2, 3...) |
| `valid_from` | Timestamp when this version became active |
| `valid_to` | Timestamp when this version was superseded (NULL = current) |
| `op_type` | Operation type: `INSERT`, `UPDATE`, or `DELETE` |

### Repository Pattern

Every repository mutation MUST follow this pattern:

```go
func (r *Repo) Update(ctx context.Context, entity Entity) error {
    // 1. Get current version
    current, err := r.GetByID(ctx, entity.ID)

    // 2. Close current version
    tx.Exec("UPDATE table SET valid_to = ? WHERE entity_id = ? AND valid_to IS NULL", now, current.EntityID)

    // 3. Get next version number
    tx.QueryRow("SELECT MAX(version) FROM table WHERE entity_id = ?", current.EntityID)

    // 4. Insert new version
    tx.Exec("INSERT INTO table (..., entity_id, version, valid_from, op_type) VALUES (..., ?, ?, ?, 'UPDATE')",
        current.EntityID, maxVersion+1, now)
}
```

### GetByID Semantics

`GetByID(id)` returns the **current version** of the entity, even if `id` refers to an old row:
1. Look up `entity_id` for the given `id`
2. Return current version (`valid_to IS NULL AND op_type != 'DELETE'`) for that `entity_id`

### Why This Matters

- Full audit trail of all changes
- Point-in-time queries (`GetAsOf`)
- Undo/restore deleted items
- No data loss from updates

**If you write a repository method that does `UPDATE ... SET` without creating a new version, STOP and rewrite it.**

## Core Philosophy

**TEST-DRIVEN DEVELOPMENT IS NON-NEGOTIABLE.** Every line of production code must be written in response to a failing test. No exceptions.

## TDD Checkpoints (MANDATORY)

Before writing ANY production code, you MUST:

1. **Say "RED:" explicitly** - Write "RED: Writing failing test for [specific behavior]"
2. **Write the test first** - Create the test file/function
3. **Run and show failure** - Execute `go test` and display the failure
4. **Only then say "GREEN:"** - Write "GREEN: Implementing [specific behavior]"
5. **Write minimum code** - Just enough to pass the test
6. **Run and show success** - Execute `go test` and display passing
7. **Say "REFACTOR:"** - Assess if refactoring adds value, do it if so

**If you catch yourself writing production code without a failing test, STOP IMMEDIATELY:**
- Delete the production code you wrote
- Go back to step 1
- This applies even for "simple" fixes

## "Hard to Test" is Not an Excuse

If something feels hard to test (CLI commands, integration points, etc.):

1. **Extract the logic** into a pure, testable function
2. **Write the test FIRST** for that extracted function
3. **Then integrate** the tested function into the harder-to-test code

Never skip tests because:
- "It's just CLI glue code"
- "It's an integration point"
- "It's a simple one-liner"
- "I'll add tests later"

## Development Workflow

**RED-GREEN-REFACTOR:**
1. RED: Write failing test first (NO production code without failing test)
2. GREEN: Write MINIMUM code to pass test
3. REFACTOR: Assess improvement opportunities (only if adds value)
4. **Wait for commit approval** before every commit

## Git & GitHub Workflow

### Merging Pull Requests

**CRITICAL**: This repository has branch protection rules enabled. Standard merge attempts will fail.

**Always use the `--admin` flag when merging PRs:**

```bash
gh pr merge [PR_NUMBER] --squash --delete-branch --admin
```

Without `--admin`, you will see: `the base branch policy prohibits the merge`

## Code Style

**Functional patterns adapted for Go:**
- Prefer immutability where practical
- Pure functions wherever possible
- No nested if/else - use early returns
- No comments - code should be self-documenting
- Table-driven tests for comprehensive coverage

**Testing:**
- Test behavior, not implementation
- Use test helpers/factories for test data
- Tests document expected business behavior
- 100% coverage in `internal/domain` before other layers

## 12-Factor Patterns

- **Config:** Environment variables (`GEMINI_API_KEY`, `DB_PATH`)
- **Logs:** Diagnostic messages to stderr, data output to stdout
- **Dependencies:** Strict via go.mod

## Implementation Order

1. Domain Layer first: Types + TreeParser with 100% TDD
2. Service Layer: BujoService, HabitService (UI-agnostic)
3. Infrastructure: SQLite repositories with golang-migrate
4. Adapter (CLI): Cobra commands
5. Adapter (AI): Gemini with rolling summary logic

For detailed specifications, see `spec.md`.

## Recent Architectural Patterns

### Immutability in Domain Layer
Domain objects should use value receivers and return new instances rather than mutating state:

```go
// ✓ Correct: Returns new instance
func (g Goal) MarkDone() Goal {
    g.Status = GoalStatusDone
    return g
}

// ✗ Incorrect: Mutates receiver
func (g *Goal) MarkDone() {
    g.Status = GoalStatusDone
}
```

**Rationale:** Immutability prevents subtle bugs, makes code easier to reason about, and aligns with functional programming principles.

### Stateless Services
Services should accept configuration as method parameters rather than storing as state:

```go
// ✓ Correct: Stateless
func (s *BackupService) CreateBackup(ctx context.Context, backupDir string) (string, error)

// ✗ Incorrect: Stateful
type BackupService struct {
    backupDir string  // Configuration stored as state
}
```

**Rationale:** Stateless services are more testable, composable, and align with functional programming principles.

### Magic Numbers as Named Constants
Extract repeated numeric literals as named constants for clarity:

```go
// ✓ Correct: Named constants
const (
    HabitDaysWeek    = 7
    HabitDaysMonth   = 30
    HabitDaysQuarter = 90
)

// ✗ Incorrect: Magic numbers
days := 7
if viewMode == Month {
    days = 30
}
```

**Rationale:** Named constants improve code readability, reduce errors, and make future changes easier.

### Enum Pattern for State Machines
Use iota-based enums for multi-state cycles:

```go
type HabitViewMode int

const (
    HabitViewModeWeek HabitViewMode = iota  // 0
    HabitViewModeMonth                       // 1
    HabitViewModeQuarter                     // 2
)
```

**Rationale:** Enums are type-safe, self-documenting, and extensible compared to booleans.

### UI Truncation for Long Content
Implement truncation with clear indicators for user-facing display:

```go
const maxAncestors = 3
const maxContentLen = 40

if len(ancestors) > maxAncestors {
    prefix = "... > "
}
if len(content) > maxContentLen {
    content = content[:maxContentLen] + "..."
}
```

**Rationale:** Prevents UI overflow while maintaining usability. Magic numbers here are acceptable as UI constraints.

### Repository Pattern for Infrastructure
Services depend on repository interfaces, not concrete implementations:

```go
// Service layer defines interface
type BackupRepository interface {
    Backup(ctx context.Context, destPath string) error
}

// Infrastructure provides implementation
type SQLiteBackupRepository struct {
    db *sql.DB
}
```

**Rationale:** Enables testing with mocks, supports multiple backends, follows hexagonal architecture.