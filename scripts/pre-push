#!/bin/sh

# Pre-push hook for bujo
# Runs quality checks appropriate to the files being pushed
#
# Output is suppressed to reduce context consumption in AI tools.
# Full logs are written to /tmp/pre-push-*.log on failure.
#
# Installation:
#   cp scripts/pre-push .git/hooks/pre-push
#   chmod +x .git/hooks/pre-push

set -e  # Exit on first error

# Log file for verbose output
LOG_FILE="/tmp/pre-push-$$.log"
cleanup() { rm -f "$LOG_FILE" 2>/dev/null; }
trap cleanup EXIT

# Run command silently, show summary only
run_check() {
    local name="$1"
    shift
    printf "  %s... " "$name"
    if "$@" >> "$LOG_FILE" 2>&1; then
        echo "‚úì"
        return 0
    else
        echo "‚úó"
        return 1
    fi
}

# Read push info from stdin
ZERO_SHA="0000000000000000000000000000000000000000"
has_code_changes=false
changed_files=""

while read local_ref local_sha remote_ref remote_sha; do
    if [ "$local_sha" = "$ZERO_SHA" ]; then
        continue
    fi
    case "$local_ref" in
        refs/tags/*) continue ;;
    esac
    if [ "$remote_sha" = "$ZERO_SHA" ]; then
        base=$(git merge-base HEAD origin/main 2>/dev/null || git merge-base HEAD origin/master 2>/dev/null || echo "")
        if [ -n "$base" ]; then
            range="$base..$local_sha"
        else
            range="$local_sha~1..$local_sha"
        fi
    else
        range="$remote_sha..$local_sha"
    fi
    files=$(git diff --name-only "$range" 2>/dev/null || echo "")
    if [ -n "$files" ]; then
        has_code_changes=true
        changed_files="$changed_files
$files"
    fi
done

if [ "$has_code_changes" = "false" ]; then
    echo "‚ÑπÔ∏è  No code changes. Skipping checks."
    exit 0
fi

changed_files=$(echo "$changed_files" | sort -u | grep -v '^$' || true)
if [ -z "$changed_files" ]; then
    echo "‚ÑπÔ∏è  No file changes. Skipping checks."
    exit 0
fi

# Detect change types
has_go_changes=false
has_frontend_changes=false
has_workflow_changes=false
has_code_changes=false

for file in $changed_files; do
    case "$file" in
        *.go|go.mod|go.sum) has_go_changes=true; has_code_changes=true ;;
        frontend/*) has_frontend_changes=true; has_code_changes=true ;;
        .github/workflows/*.yml|.github/workflows/*.yaml) has_workflow_changes=true ;;
        *.md|docs/*|.github/*|LICENSE|.gitignore|.claude/*|scripts/*) ;;
        *) has_code_changes=true ;;
    esac
done

if [ "$has_code_changes" = "false" ] && [ "$has_workflow_changes" = "false" ]; then
    echo "‚ÑπÔ∏è  Only docs/config changes. Skipping checks."
    exit 0
fi

total=$(echo "$changed_files" | wc -l | tr -d ' ')
echo "üîç Pre-push checks ($total files)"

failed=false

# Go checks
if [ "$has_go_changes" = "true" ]; then
    echo "üì¶ Go:"

    # gofmt
    printf "  gofmt... "
    unformatted=$(gofmt -l . 2>/dev/null)
    if [ -n "$unformatted" ]; then
        echo "‚úó (run: gofmt -w .)"
        echo "Unformatted: $unformatted" >> "$LOG_FILE"
        failed=true
    else
        echo "‚úì"
    fi

    # go mod tidy
    printf "  go mod tidy... "
    cp go.mod go.mod.backup 2>/dev/null
    cp go.sum go.sum.backup 2>/dev/null
    go mod tidy >> "$LOG_FILE" 2>&1
    if ! diff -q go.mod go.mod.backup > /dev/null 2>&1 || ! diff -q go.sum go.sum.backup > /dev/null 2>&1; then
        echo "‚úó (run: go mod tidy)"
        mv go.mod.backup go.mod
        mv go.sum.backup go.sum
        failed=true
    else
        rm -f go.mod.backup go.sum.backup
        echo "‚úì"
    fi

    run_check "go build" go build ./cmd/bujo ./internal/... || failed=true
    run_check "go test" go test ./... || failed=true
    run_check "go vet" go vet ./... || failed=true

    if command -v golangci-lint &> /dev/null; then
        run_check "golangci-lint" golangci-lint run || failed=true
    fi
fi

# Frontend checks
if [ "$has_frontend_changes" = "true" ] && [ -d "frontend" ]; then
    echo "üåê Frontend:"
    (cd frontend && run_check "lint" npm run lint) || failed=true
    (cd frontend && run_check "tsc" npx tsc --noEmit) || failed=true
    (cd frontend && run_check "test" npm test) || failed=true
    (cd frontend && run_check "build" npm run build) || failed=true
    (cd frontend && run_check "audit" npm audit --audit-level=high) || failed=true
fi

# Workflow checks
if [ "$has_workflow_changes" = "true" ]; then
    echo "‚öôÔ∏è  Workflows:"
    if command -v actionlint &> /dev/null; then
        workflow_files=$(echo "$changed_files" | grep -E '\.github/workflows/.*\.ya?ml$' || true)
        for wf in $workflow_files; do
            if [ -f "$wf" ]; then
                run_check "actionlint $wf" actionlint "$wf" || failed=true
            fi
        done
    else
        echo "  actionlint... ‚ö†Ô∏è  (not installed)"
    fi
fi

if [ "$failed" = "true" ]; then
    echo ""
    echo "‚ùå Pre-push failed. Logs: $LOG_FILE"
    trap - EXIT  # Keep log file on failure
    exit 1
fi

echo "‚úÖ All checks passed"
